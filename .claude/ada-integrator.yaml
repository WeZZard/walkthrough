# ADA-Specific Integrator Configuration
# Handles cross-language failures unique to ADA's architecture

name: ada-cross-language-integrator
description: Analyzes failures across C++/Rust/Python boundaries in ADA's dual-lane architecture

failure_patterns:
  # C++ → Rust FFI Issues
  frida_hook_failures:
    symptoms:
      - "undefined symbol: thread_registry_"
      - "dlsym failed"
      - "cannot load native extension"
    analysis:
      - Check: C API exports in tracer_backend
      - Check: build.rs linking configuration
      - Check: Frida GModule loading
    resolution:
      agent: cpp-developer
      focus: "Verify extern 'C' exports and symbol visibility"
  
  # Shared Memory Issues
  ring_buffer_corruption:
    symptoms:
      - "Segmentation fault in ring_buffer"
      - "Data race detected"
      - "Atomic operation on misaligned address"
    analysis:
      - Check: 64-byte cache line alignment
      - Check: Memory ordering (acquire/release)
      - Check: SPSC invariants maintained
    resolution:
      agent: cpp-integrator
      focus: "Validate atomic operations and alignment"
  
  # Performance Violations
  latency_requirements_failed:
    symptoms:
      - "Registration took > 1μs"
      - "Fast path exceeded 10ns"
      - "Lock contention detected"
    analysis:
      - Check: No allocations in hot path
      - Check: Lock-free implementation correct
      - Check: Cache-line false sharing
    resolution:
      agent: performance-benchmark-engineer
      focus: "Profile and optimize critical paths"
  
  # Python Token Budget Issues
  token_overflow:
    symptoms:
      - "TokenBudgetExceeded"
      - "Context window overflow"
      - "Truncation error in query"
    analysis:
      - Check: tiktoken counting accuracy
      - Check: Budget calculation logic
      - Check: Priority queue implementation
    resolution:
      agent: python-integrator
      focus: "Validate token counting and prioritization"

# Cross-Language Interface Validation
interface_validation:
  c_to_rust:
    validate:
      - C headers match Rust bindgen output
      - Opaque pointers properly handled
      - Memory ownership clear
    test_command: |
      cargo test --package tracer_backend --test ffi_test
  
  rust_to_python:
    validate:
      - PyO3 bindings match Python protocols
      - Type conversions correct
      - GIL handling proper
    test_command: |
      cargo test --package query_engine --test python_binding_test
  
  shared_memory:
    validate:
      - Atomics work across languages
      - Cache alignment preserved
      - No ABI incompatibilities
    test_command: |
      cargo test --package tracer_backend --test shared_memory_test

# ADA-Specific Triple-Check Protocol
ada_triple_check:
  interface_check:
    - ThreadRegistry C API compiles
    - TracerControl trait compiles
    - QueryEngine Protocol imports
    - All skeletons instantiate
  
  implementation_check:
    - Frida hooks register correctly
    - Ring buffers are lock-free
    - Token counting is accurate
    - Performance bounds met
  
  test_check:
    - Cross-language tests pass
    - Performance benchmarks pass
    - Memory sanitizers clean
    - Thread sanitizer clean

# Performance Validation Thresholds
performance_gates:
  registration:
    max_latency: 1000  # nanoseconds
    measurement: "thread_registry_register() duration"
  
  fast_path:
    max_latency: 10    # nanoseconds
    measurement: "event write to ring buffer"
  
  memory:
    max_allocation_rate: 0  # bytes/sec in steady state
    measurement: "heap allocation in hot path"

# Build System Integration
build_validation:
  cargo_drives_all:
    - Never run CMake directly
    - Never run pytest directly
    - All through cargo commands
  
  test_discovery:
    c_tests:
      location: "build.rs binaries list"
      common_mistake: "Test added to CMakeLists.txt but not build.rs"
    
    rust_tests:
      location: "Standard cargo test"
      
    python_tests:
      location: "Via cargo test in query_engine"
      common_mistake: "Running pytest directly instead of cargo"

# Agent Routing for ADA Issues
routing_rules:
  - pattern: "Frida|hook|intercept"
    agent: cpp-developer
    reason: "Frida is C++ domain"
  
  - pattern: "ring_buffer|SPSC|atomic"
    agent: cpp-integrator
    reason: "Lock-free structures need deep analysis"
  
  - pattern: "cargo|workspace|build.rs"
    agent: rust-developer
    reason: "Build orchestration is Rust's responsibility"
  
  - pattern: "token|tiktoken|MCP"
    agent: python-developer
    reason: "Query engine and MCP are Python"
  
  - pattern: "performance|latency|benchmark"
    agent: performance-benchmark-engineer
    reason: "Specialized performance analysis needed"