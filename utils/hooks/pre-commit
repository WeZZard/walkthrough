#!/bin/bash
# Pre-commit hook for quality gate enforcement
# Per CLAUDE.md: 100% test coverage for changed code, no exceptions

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

REPO_ROOT="$(git rev-parse --show-toplevel)"
UTILS_DIR="${REPO_ROOT}/utils"

echo -e "${BLUE}[PRE-COMMIT]${NC} Running quality gate checks..."

# Quick check if only documentation files are being committed
STAGED_FILES=$(git diff --cached --name-only)
if [[ -n "$STAGED_FILES" ]]; then
    NON_DOC_FILES=$(echo "$STAGED_FILES" | grep -v -E '\.(md|txt|rst|adoc|org)$' | \
        grep -v -E '^(docs/|documentation/|README|LICENSE|CHANGELOG|AUTHORS|CONTRIBUTORS)' || true)
    
    if [[ -z "$NON_DOC_FILES" ]]; then
        echo -e "${GREEN}[PRE-COMMIT]${NC} Documentation-only commit detected"
        echo -e "${BLUE}[INFO]${NC} Files being committed:"
        echo "$STAGED_FILES" | sed 's/^/  • /'
        echo -e "${GREEN}[✓]${NC} Skipping build/test/coverage checks for documentation"
    fi
fi

# Check if integration quality script exists
QUALITY_SCRIPT="${UTILS_DIR}/metrics/integration_quality.sh"
if [[ ! -f "$QUALITY_SCRIPT" ]]; then
    echo -e "${RED}[ERROR]${NC} integration_quality.sh not found!"
    echo "Please ensure scripts are properly installed."
    exit 1
fi

# Make script executable
chmod +x "$QUALITY_SCRIPT"

# Run incremental quality check for staged files
echo -e "${BLUE}[PRE-COMMIT]${NC} Checking incremental coverage for staged changes..."

# Execute the script (it has #!/bin/bash shebang)
# Use || true to prevent set -e from exiting on non-zero codes
"$QUALITY_SCRIPT" incremental || QUALITY_EXIT_CODE=$?
# If the command succeeded (exit 0), we need to set the code manually
QUALITY_EXIT_CODE=${QUALITY_EXIT_CODE:-0}

# Handle exit codes:
# 0 = passed
# 1 = blocked/failed
# 2 = documentation-only (should pass)
if [[ $QUALITY_EXIT_CODE -eq 1 ]]; then
    exit 1
elif [[ $QUALITY_EXIT_CODE -eq 2 ]]; then
    # Documentation-only changes are allowed
    :
fi

# Coverage is already checked by integration_quality.sh in incremental mode
# No need for additional coverage check here

echo -e "${BLUE}[PRE-COMMIT]${NC} Checking for compiled binaries..."

# Check for compiled binaries
BINARY_PATTERNS="*.exe *.dll *.so *.dylib *.a *.o *.pyc *.pyo __pycache__"
for pattern in $BINARY_PATTERNS; do
    if git diff --cached --name-only | grep -q "$pattern"; then
        echo -e "${RED}[ERROR]${NC} Attempting to commit compiled binaries!"
        echo -e "${RED}Binary files matching pattern '$pattern' detected${NC}"
        echo -e "${RED}Per CLAUDE.md: NEVER commit compiled binaries${NC}"
        exit 1
    fi
done

echo -e "${BLUE}[PRE-COMMIT]${NC} Checking for secrets/credentials..."

# Check for secrets/credentials
echo -e "${BLUE}[PRE-COMMIT]${NC} Scanning for potential secrets..."
SUSPICIOUS_PATTERNS=(
    "password[[:space:]]*="
    "api_key[[:space:]]*="
    "secret[[:space:]]*="
    "token[[:space:]]*="
    "BEGIN RSA"
    "BEGIN DSA"
    "BEGIN EC"
    "BEGIN OPENSSH"
    "aws_access_key"
    "aws_secret_key"
)

for pattern in "${SUSPICIOUS_PATTERNS[@]}"; do
    # Check if pattern exists but exclude obvious documentation/examples
    if git diff --cached | grep -i "$pattern" | grep -v "uuidgen" | grep -v "example" | grep -v "your.*password" | grep -v "placeholder" > /dev/null 2>&1; then
        echo -e "${RED}[ERROR]${NC} Potential secret/credential detected!"
        echo -e "${RED}Pattern matched: $pattern${NC}"
        echo -e "${RED}Please remove sensitive information before committing${NC}"
        exit 1
    fi
done

exit 0